use crate::{Condition, PacketId, PacketStructDefinition, StructDefinition, StructField};
use std::fs::File;
use std::io::Write;
use std::path::Path;

pub fn write_packets_struct(packets: Vec<PacketStructDefinition>, nested_structures: &Vec<StructDefinition>, output_path: &Path) {
    let file_packets_res = File::create(output_path.join("packets.rs"));
    let file_packets_impl_res = File::create(output_path.join("packets_impl.rs"));
    let file_print_res = File::create(output_path.join("packets_print.rs"));
    let file_packets_parser_res = File::create(output_path.join("packets_parser.rs"));
    let mut file_packets = file_packets_res.unwrap();
    let mut file_packets_print = file_print_res.unwrap();
    let mut file_packets_impl = file_packets_impl_res.unwrap();
    let mut file_packets_parser = file_packets_parser_res.unwrap();
    write_file_header(&mut file_packets);
    write_file_header(&mut file_packets_print);
    write_file_header(&mut file_packets_impl);
    write_file_header(&mut file_packets_parser);

    file_packets.write_all("#![allow(dead_code)]\n\n".to_string().as_bytes()).unwrap();
    file_packets.write_all("use std::any::Any;\n\n".to_string().as_bytes()).unwrap();

    file_packets_print.write_all("#![allow(dead_code)]\n\n".to_string().as_bytes()).unwrap();
    file_packets_print.write_all("use crate::packets::*;\n".to_string().as_bytes()).unwrap();
    file_packets_print.write_all("use std::fmt::{Formatter, Debug, Display};\n".to_string().as_bytes()).unwrap();
    file_packets_print.write_all("use crate::print::PrettyOutput;\n\n".to_string().as_bytes()).unwrap();

    file_packets_parser.write_all("use crate::packets::*;\n\n".to_string().as_bytes()).unwrap();

    file_packets_impl.write_all("#![allow(dead_code)]\n\n".to_string().as_bytes()).unwrap();
    file_packets_impl.write_all("#![allow(unused_assignments)]\n\n".to_string().as_bytes()).unwrap();
    file_packets_impl.write_all("#![allow(unused_variables)]\n\n".to_string().as_bytes()).unwrap();
    file_packets_impl.write_all("use crate::packets::*;\n".to_string().as_bytes()).unwrap();
    file_packets_impl.write_all("use byteorder::{LittleEndian,WriteBytesExt};\n".to_string().as_bytes()).unwrap();
    file_packets_impl.write_all("use std::any::Any;\n".to_string().as_bytes()).unwrap();
    file_packets_impl.write_all("use std::convert::TryInto;\n\n".to_string().as_bytes()).unwrap();

    write_packet_parser(&mut file_packets_parser, &packets);
    write_packet_trait(&mut file_packets);
    for packet in packets {
        write_struct_definition(&mut file_packets, &packet.struct_def);
        write_struct_impl(&mut file_packets_impl, &packet.struct_def, Some(packet.ids.clone()));
        write_packet_trait_impl(&mut file_packets_impl, &packet);
        write_debug_trait(&mut file_packets_print, &packet.struct_def);
        write_display_trait(&mut file_packets_print, &packet.struct_def, true);
    }

    for nested_struct in nested_structures {
        write_struct_definition(&mut file_packets, nested_struct);
        write_struct_impl(&mut file_packets_impl, nested_struct, None);
        write_debug_trait(&mut file_packets_print, nested_struct);
        write_display_trait(&mut file_packets_print, nested_struct, false);
    }
    write_unknown_packet(&mut file_packets);
}

fn write_file_header(file: &mut File) {
    file.write_all("// Generated by tools/packets_db/main.rs\n".to_string().as_bytes()).unwrap();
    file.write_all("// Auto generated file do not edit manually\n\n".to_string().as_bytes()).unwrap();
}

fn write_packet_parser(file: &mut File, packets: &[PacketStructDefinition]) {
    file.write_all("pub fn parse(buffer: &[u8], packetver: u32) -> Box<dyn Packet> {\n".to_string().as_bytes()).unwrap();
    #[derive(Clone)]
    struct PacketAndVersion {
        id: String,
        version: Option<u32>,
        struct_name: String,
    }
    let mut packets_with_version = vec![];
    packets.iter().for_each(|struct_def| struct_def.ids.iter().for_each(|packet_id| {
        packets_with_version.push(PacketAndVersion { id: packet_id.id.clone(), version: packet_id.packetver, struct_name: struct_def.struct_def.name.clone() })
    }));
    let mut ids_with_version = packets_with_version.iter().filter(|packet| packet.version.is_some()).cloned().collect::<Vec<PacketAndVersion>>();
    let ids_without_version = packets_with_version.iter().filter(|packet| packet.version.is_none()).cloned().collect::<Vec<PacketAndVersion>>();
    ids_with_version.sort_by(|a, b| (b.version.unwrap()).cmp(&a.version.unwrap()));
    for packet in ids_with_version.iter() {
        let packet_id = packet_id(&packet.id.clone()).replace("0x", "");
        let (first_byte, second_byte) = packet_id.split_at(2);
        file.write_all(format!("    if packetver >= {} && buffer[0] == 0x{first_byte} && buffer[1] == 0x{second_byte} {{\n", packet.version.unwrap()).as_bytes()).unwrap();
        file.write_all(format!("        return Box::new({}::from(buffer, packetver));\n", packet.struct_name).as_bytes()).unwrap();
        file.write_all("    }\n".to_string().as_bytes()).unwrap();
    }
    for packet in ids_without_version.iter() {
        let packet_id = packet_id(&packet.id.clone()).replace("0x", "");
        let (first_byte, second_byte) = packet_id.split_at(2);
        file.write_all(format!("    if buffer[0] == 0x{first_byte} && buffer[1] == 0x{second_byte} {{\n").as_bytes()).unwrap();
        file.write_all(format!("        return Box::new({}::from(buffer, packetver));\n", packet.struct_name).as_bytes()).unwrap();
        file.write_all("    }\n".to_string().as_bytes()).unwrap();
    }
    file.write_all("    Box::new(PacketUnknown::from(buffer))\n".to_string().as_bytes()).unwrap();
    file.write_all("}\n\n".to_string().as_bytes()).unwrap();


    file.write_all("pub fn parse_json(json: &str, packetver: u32) -> Result<Box<dyn Packet>, String> {\n".to_string().as_bytes()).unwrap();
    file.write_all("    let entries: Vec<json_flat_parser::FlatJsonValue<&str>> = json_flat_parser::JSONParser::parse(json, json_flat_parser::ParseOptions::default().keep_object_raw_data(false))?.json;\n".as_bytes()).unwrap();
    file.write_all("    if let Some(packet_id) = entries.iter().find(|entry| entry.pointer.pointer.eq(\"/packet_id\")){\n".as_bytes()).unwrap();
    for packet in ids_with_version.iter() {
        let packet_id = packet_id(&packet.id.clone());
        file.write_all(format!("    if packetver >= {} && packet_id.value.unwrap().eq(\"{}\") {{\n", packet.version.unwrap(), packet_id).as_bytes()).unwrap();
        file.write_all(format!("        return  {}::from_json(entries, packetver).map(|p| Box::new(p) as Box<dyn Packet>);\n", packet.struct_name).as_bytes()).unwrap();
        file.write_all("    }\n".to_string().as_bytes()).unwrap();
    }
    for packet in ids_without_version.iter() {
        let packet_id = packet_id(&packet.id.clone());
        file.write_all(format!("    if packet_id.value.unwrap().eq(\"{}\") {{\n", packet_id).as_bytes()).unwrap();
        file.write_all(format!("        return {}::from_json(entries, packetver).map(|p| Box::new(p) as Box<dyn Packet>);\n", packet.struct_name).as_bytes()).unwrap();
        file.write_all("    }\n".to_string().as_bytes()).unwrap();
    }
    file.write_all("    }\n".as_bytes()).unwrap();
    file.write_all("    PacketUnknown::from_json(entries, packetver).map(|p| Box::new(p)  as Box<dyn Packet>)\n".to_string().as_bytes()).unwrap();
    file.write_all("}\n\n".to_string().as_bytes()).unwrap();
}

fn write_packet_trait(file: &mut File) {
    file.write_all("pub trait Packet {\n".to_string().as_bytes()).unwrap();
    file.write_all("    fn id(&self, packetver: u32) -> &str;\n".to_string().as_bytes()).unwrap();
    file.write_all("    fn name(&self) -> &str;\n".to_string().as_bytes()).unwrap();
    file.write_all("    fn base_len(&self, packetver: u32) -> usize;\n".to_string().as_bytes()).unwrap();
    file.write_all("    fn display(&self);\n".to_string().as_bytes()).unwrap();
    file.write_all("    fn debug(&self);\n".to_string().as_bytes()).unwrap();
    file.write_all("    fn pretty_debug(&self);\n".to_string().as_bytes()).unwrap();
    file.write_all("    fn fill_raw(&mut self);\n".to_string().as_bytes()).unwrap();
    file.write_all("    fn fill_raw_with_packetver(&mut self, packetver: Option<u32>);\n".to_string().as_bytes()).unwrap();
    file.write_all("    fn raw(&self) -> &Vec<u8>;\n".to_string().as_bytes()).unwrap();
    file.write_all("    fn raw_mut(&mut self) -> &mut Vec<u8>;\n".to_string().as_bytes()).unwrap();
    file.write_all("    fn as_any(&self) -> &dyn Any;\n".to_string().as_bytes()).unwrap();
    file.write_all("    fn as_any_mut(&mut self) -> &mut dyn Any;\n".to_string().as_bytes()).unwrap();
    file.write_all("    fn to_json(&self, packetver: u32) -> String;\n".to_string().as_bytes()).unwrap();
    file.write_all("}\n\n".to_string().as_bytes()).unwrap();
}

fn write_packet_trait_impl(file: &mut File, packet: &PacketStructDefinition) {
    file.write_all(format!("impl Packet for {} {{\n", packet.struct_def.name).as_bytes()).unwrap();
    file.write_all("    fn id(&self, packetver: u32) -> &str {\n".to_string().as_bytes()).unwrap();
    file.write_all(format!("       {}::packet_id(packetver)\n", packet.struct_def.name).as_bytes()).unwrap();
    file.write_all("    }\n".to_string().as_bytes()).unwrap();
    file.write_all("    fn name(&self) -> &str {\n".to_string().as_bytes()).unwrap();
    file.write_all(format!("       \"{}\"\n", packet.struct_def.name).as_bytes()).unwrap();
    file.write_all("    }\n".to_string().as_bytes()).unwrap();
    file.write_all("    fn debug(&self) {\n".to_string().as_bytes()).unwrap();
    file.write_all("            println!(\"{:?}\", self)\n".to_string().as_bytes()).unwrap();
    file.write_all("    }\n".to_string().as_bytes()).unwrap();
    file.write_all("    fn display(&self) {\n".to_string().as_bytes()).unwrap();
    file.write_all("            println!(\"{}\", self)\n".to_string().as_bytes()).unwrap();
    file.write_all("    }\n".to_string().as_bytes()).unwrap();
    file.write_all("    fn pretty_debug(&self) {\n".to_string().as_bytes()).unwrap();
    file.write_all("            println!(\"{:#?}\", self)\n".to_string().as_bytes()).unwrap();
    file.write_all("    }\n".to_string().as_bytes()).unwrap();
    file.write_all("    fn raw(&self) -> &Vec<u8> {\n".to_string().as_bytes()).unwrap();
    file.write_all("            &self.raw\n".to_string().as_bytes()).unwrap();
    file.write_all("    }\n".to_string().as_bytes()).unwrap();
    file.write_all("    fn raw_mut(&mut self) -> &mut Vec<u8> {\n".to_string().as_bytes()).unwrap();
    file.write_all("            &mut self.raw\n".to_string().as_bytes()).unwrap();
    file.write_all("    }\n".to_string().as_bytes()).unwrap();
    file.write_all("    fn as_any(&self) -> &dyn Any{\n".to_string().as_bytes()).unwrap();
    file.write_all("        self\n".to_string().as_bytes()).unwrap();
    file.write_all("    }\n".to_string().as_bytes()).unwrap();
    file.write_all("    fn as_any_mut(&mut self) -> &mut dyn Any{\n".to_string().as_bytes()).unwrap();
    file.write_all("        self\n".to_string().as_bytes()).unwrap();
    file.write_all("    }\n".to_string().as_bytes()).unwrap();
    file.write_all("    fn base_len(&self, packetver: u32) -> usize {\n".to_string().as_bytes()).unwrap();
    file.write_all("        Self::base_len(packetver)\n".to_string().as_bytes()).unwrap();
    file.write_all("    }\n".to_string().as_bytes()).unwrap();
    write_struct_to_json(file, &packet.struct_def);
    write_struct_fill_raw_method(file, false);
    write_struct_fill_raw_with_packetver_method(file, &packet.struct_def, false);
    file.write_all("}\n\n".to_string().as_bytes()).unwrap();
}


fn write_debug_trait(file: &mut File, struct_definition: &StructDefinition) {
    file.write_all(format!("impl Debug for {} {{\n", struct_definition.name).as_bytes()).unwrap();
    file.write_all("    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {\n".to_string().as_bytes()).unwrap();
    file.write_all(format!("        f.debug_struct(\"{}\")\n", struct_definition.name).as_bytes()).unwrap();
    for field in &struct_definition.fields {
        file.write_all(format!("            .field(\"{}[{}, {}]\", &format!(\"{{:02X?}}\", &self.{}_raw))\n",
                               field.name,
                               field.position, if field.length > -1 { (field.position + field.length).to_string() } else { "?".to_string() },
                               field.name
        ).as_bytes()).unwrap();
    }
    file.write_all("        .finish()\n".to_string().as_bytes()).unwrap();
    file.write_all("    }\n".to_string().as_bytes()).unwrap();
    file.write_all("}\n\n".to_string().as_bytes()).unwrap();
}

fn write_display_trait(file: &mut File, struct_definition: &StructDefinition, _is_packet: bool) {
    file.write_all(format!("impl Display for {} {{\n", struct_definition.name).as_bytes()).unwrap();
    file.write_all("    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {\n".to_string().as_bytes()).unwrap();
    file.write_all("        let mut fields = Vec::new();\n".to_string().as_bytes()).unwrap();
    for field in &struct_definition.fields {
        let value_to_print;
        if field.name.eq("packet_id") {
            file.write_all(format!("        fields.push(format!(\"{}{}[{}, {}]: 0X{{:02X?}}{{:02X?}}\", {}));\n",
                                   field.name,
                                   display_type(field),
                                   field.position, if field.length > -1 { (field.position + field.length).to_string() } else { "?".to_string() },
                                   "&self.packet_id_raw[0], &self.packet_id_raw[1]"
            ).as_bytes()).unwrap();
            continue;
        }
        if field.data_type.name == "Array" {
            value_to_print = format!("&self.{}.pretty_output()", field.name);
        } else if field.data_type.name == "Vec" {
            value_to_print = format!("&self.{}.iter().map(|item| format!(\"\n  >{{}}\", item)).collect::<String>()", field.name);
        } else {
            value_to_print = format!("&self.{}", field.name);
        }
        file.write_all(format!("        fields.push(format!(\"{}{}[{}, {}]: {{}}\", {}));\n",
                               field.name,
                               display_type(field),
                               field.position, if field.length > -1 { (field.position + field.length).to_string() } else { "?".to_string() },
                               value_to_print
        ).as_bytes()).unwrap();
    }
    file.write_all(format!("        write!(f, \"{}\\n {{}}\", fields.join(\",\\n \"))\n", struct_definition.name).as_bytes()).unwrap();
    file.write_all("    }\n".to_string().as_bytes()).unwrap();
    file.write_all("}\n\n".to_string().as_bytes()).unwrap();
}

fn write_struct_definition(file: &mut File, struct_definition: &StructDefinition) {
    file.write_all("#[derive(Clone)]\n".to_string().as_bytes()).unwrap();
    file.write_all(format!("pub struct {} {{\n", struct_definition.name).as_bytes()).unwrap();
    file.write_all("    pub raw: Vec<u8>,\n".to_string().as_bytes()).unwrap();
    for field in &struct_definition.fields {
        file.write_all(format!("    pub {}: {},\n", field.name, field_type(field)).as_bytes()).unwrap();
        file.write_all(format!("    pub {}_raw: {},\n", field.name, field_type_raw(field)).as_bytes()).unwrap();
    }
    file.write_all("}\n\n".to_string().as_bytes()).unwrap();
}

fn write_struct_impl(file: &mut File, struct_definition: &StructDefinition, packet_id: Option<Vec<PacketId>>) {
    file.write_all(format!("impl {} {{\n", struct_definition.name).as_bytes()).unwrap();
    if packet_id.is_some() {
        write_struct_packet_id_method(file, &packet_id);
    }
    write_struct_from_method(file, struct_definition);
    write_struct_base_len_method(file, struct_definition);
    write_struct_setter_methods(file, struct_definition);
    write_struct_new_method(file, struct_definition, &packet_id);
    write_struct_from_json(file, struct_definition);
    if packet_id.is_none() {
        write_struct_fill_raw_method(file, true);
        write_struct_fill_raw_with_packetver_method(file, struct_definition, true);
    }
    file.write_all("}\n\n".to_string().as_bytes()).unwrap();
}

fn write_struct_from_method(file: &mut File, struct_definition: &StructDefinition) {
    file.write_all(format!("    pub fn from(buffer: &[u8], packetver: u32) -> {} {{\n", struct_definition.name).as_bytes()).unwrap();
    file.write_all("        let mut offset: usize = 0;\n".to_string().as_bytes()).unwrap();
    let field_with_vec = struct_definition.fields.iter().find(|field| field.data_type.name == "Vec");
    if let Some(field_with_vec) = field_with_vec {
        write_vec_field(file, field_with_vec);
    }
    file.write_all(format!("        {} {{\n", struct_definition.name).as_bytes()).unwrap();
    for field in &struct_definition.fields {
        if field.data_type.name == "Vec" {
            file.write_all(format!("            {}: {{\n", field.name).as_bytes()).unwrap();
            file.write_all("                let field = vec_field.clone();\n".to_string().as_bytes()).unwrap();
            file.write_all("                field\n".to_string().as_bytes()).unwrap();
            file.write_all("            },\n".to_string().as_bytes()).unwrap();
        } else if field.data_type.name == "Struct" {
            file.write_all(format!("            {}: {{\n", field.name).as_bytes()).unwrap();
            file.write_all(format!("                let field = {}::from(&buffer[offset..offset + {}::base_len(packetver)], packetver);\n", field.complex_type.as_ref().unwrap(), field.complex_type.as_ref().unwrap()).as_bytes()).unwrap();
            file.write_all("                field\n".to_string().as_bytes()).unwrap();
            file.write_all("            },\n".to_string().as_bytes()).unwrap();
        } else {
            file.write_all(format!("            {}: {{\n", field.name).as_bytes()).unwrap();
            if field.condition.is_some() {
                file.write_all(format!("                let field = {}", packetver_if("packetver", field)).as_bytes()).unwrap();
                file.write_all(format!("                   {}\n", struct_impl_field_value(field)).as_bytes()).unwrap();
                file.write_all("                } else {\n".to_string().as_bytes()).unwrap();
                file.write_all(format!("                   {}\n", struct_impl_default_field_value(field)).as_bytes()).unwrap();
                file.write_all("                };\n".to_string().as_bytes()).unwrap();
            } else {
                file.write_all(format!("                let field = {};\n", struct_impl_field_value(field)).as_bytes()).unwrap();
            }
            file.write_all("                field\n".to_string().as_bytes()).unwrap();
            file.write_all("            },\n".to_string().as_bytes()).unwrap();
        }
        if &field.data_type.name == "Vec" {
            file.write_all(format!("            {}_raw: {{\n", field.name).as_bytes()).unwrap();
            file.write_all("                vec_field.iter().map(|item| {\n                  offset += item.raw.len();\n                  item.raw.clone()\n                }).collect::<Vec<Vec<u8>>>()\n".to_string().as_bytes()).unwrap();
            file.write_all("            },\n".to_string().as_bytes()).unwrap();
        } else if field.length > -1 {
            file.write_all(format!("            {}_raw: {{\n", field.name).as_bytes()).unwrap();
            let mut length = field.length;
            if field.data_type.name == "Array" {
                length = field.length * field.sub_type.unwrap_or_else(|| panic!("Expected subtype for field {:?}", field)).length.unwrap();
            }
            file.write_all(format!("                let mut dst: [u8; {}] = [0u8; {}];\n", length, length).as_bytes()).unwrap();
            if field.condition.is_some() {
                file.write_all(format!("                {}", packetver_if("packetver", field)).as_bytes()).unwrap();
                file.write_all(format!("                    dst.clone_from_slice(&buffer[offset..offset + {}]);\n", length).as_bytes()).unwrap();
                file.write_all(format!("                    offset += {};\n", length).as_bytes()).unwrap();
                file.write_all("                }\n".to_string().as_bytes()).unwrap();
            } else {
                file.write_all(format!("                dst.clone_from_slice(&buffer[offset..offset + {}]);\n", length).as_bytes()).unwrap();
                file.write_all(format!("                offset += {};\n", length).as_bytes()).unwrap();
            }
            file.write_all("                dst\n".to_string().as_bytes()).unwrap();
            file.write_all("            },\n".to_string().as_bytes()).unwrap();
        } else {
            file.write_all(format!("            {}_raw: {{\n", field.name).as_bytes()).unwrap();
            file.write_all(format!("                let raw = buffer[offset..{}].to_vec();\n", field_length(field)).as_bytes()).unwrap();
            file.write_all("                offset += raw.len();\n".to_string().as_bytes()).unwrap();
            file.write_all("                raw\n".to_string().as_bytes()).unwrap();
            file.write_all("            },\n".to_string().as_bytes()).unwrap();
        }
    }
    file.write_all("            raw: (&buffer[..offset]).to_vec(),\n".to_string().as_bytes()).unwrap();
    file.write_all("        }\n".to_string().as_bytes()).unwrap();
    file.write_all("    }\n".to_string().as_bytes()).unwrap();
}

fn write_struct_fill_raw_method(file: &mut File, is_pub: bool) {
    file.write_all(format!("    {}fn fill_raw(&mut self) {{\n", if is_pub { "pub "} else {""} ).as_bytes()).unwrap();
    file.write_all("      self.fill_raw_with_packetver(None)\n".to_string().as_bytes()).unwrap();
    file.write_all("    }\n".to_string().as_bytes()).unwrap();
}

fn write_struct_fill_raw_with_packetver_method(file: &mut File, struct_definition: &StructDefinition, is_pub: bool) {
    file.write_all(format!("    {}fn fill_raw_with_packetver(&mut self, packetver: Option<u32>) {{\n", if is_pub { "pub "} else {""} ).as_bytes()).unwrap();
    file.write_all("    let mut wtr;\n".to_string().as_bytes()).unwrap();
    for field in &struct_definition.fields {
        file.write_all(field_serialization(field).as_bytes()).unwrap();
        file.write_all("\n".to_string().as_bytes()).unwrap();
    }
    file.write_all("\n".to_string().as_bytes()).unwrap();
    file.write_all("        wtr = vec![];\n".to_string().as_bytes()).unwrap();
    for field in &struct_definition.fields {
        if field.data_type.name == "Vec" && field.complex_type.is_some() {
            file.write_all(format!("        self.{}.iter_mut().for_each(|item| wtr.append(&mut item.raw));\n", field.name).as_bytes()).unwrap();
        } else if field.condition.is_none() {
            file.write_all(format!("        wtr.append(&mut self.{}_raw.to_vec());\n", field.name).as_bytes()).unwrap();
        } else {
            file.write_all("        if packetver.is_none() {\n".to_string().as_bytes()).unwrap();
            file.write_all(format!("          wtr.append(&mut self.{}_raw.to_vec());\n", field.name).as_bytes()).unwrap();
            file.write_all(format!("        }} else {}", packetver_if("packetver.unwrap()", field)).as_bytes()).unwrap();
            file.write_all(format!("            wtr.append(&mut self.{}_raw.to_vec());\n", field.name).as_bytes()).unwrap();
            file.write_all("        }\n".to_string().as_bytes()).unwrap();
        }
    }
    file.write_all("        self.raw = wtr;\n".to_string().as_bytes()).unwrap();
    file.write_all("    }\n".to_string().as_bytes()).unwrap();
}

fn write_struct_setter_methods(file: &mut File, struct_definition: &StructDefinition) {
    for field in &struct_definition.fields {
        file.write_all(format!("    pub fn set_{}(&mut self, value: {}) {{\n", field.name, field_type(field)).as_bytes()).unwrap();
        file.write_all(format!("        self.{} = value;\n", field.name).as_bytes()).unwrap();
        file.write_all("    }\n".to_string().as_bytes()).unwrap();
        file.write_all(format!("    pub fn set_{}_raw(&mut self, value: {}) {{\n", field.name, field_type_raw(field)).as_bytes()).unwrap();
        file.write_all(format!("        self.{}_raw = value;\n", field.name).as_bytes()).unwrap();
        file.write_all("    }\n".to_string().as_bytes()).unwrap();
    }
}

fn write_struct_base_len_method(file: &mut File, struct_definition: &StructDefinition) {
    file.write_all("    pub fn base_len(packetver: u32) -> usize {\n".to_string().as_bytes()).unwrap();
    let base_len_is_mut = struct_definition.fields.iter().filter(|f| f.condition.is_some()).count() > 0;
    file.write_all(format!("        let {} base_len: usize = {};\n", if base_len_is_mut { "mut" } else { "" }, struct_definition.fields.iter().filter(|f| f.condition.is_none() && f.data_type.name != "Vec" && f.length > -1).map(|f| f.length).sum::<i16>()).as_bytes()).unwrap();
    for f in struct_definition.fields.iter().filter(|f| f.condition.is_some()) {
        file.write_all(format!("        {}", packetver_if("packetver", f)).as_bytes()).unwrap();
        file.write_all(format!("            base_len += {};\n", f.length).as_bytes()).unwrap();
        file.write_all("        }\n".to_string().as_bytes()).unwrap();
    }
    file.write_all("        base_len\n".to_string().as_bytes()).unwrap();
    file.write_all("    }\n".to_string().as_bytes()).unwrap();
}

fn write_struct_packet_id_method(file: &mut File, ids: &Option<Vec<PacketId>>) {
    file.write_all("    pub fn packet_id(packetver: u32) -> &'static str {\n".to_string().as_bytes()).unwrap();
    let ids = ids.clone().unwrap();
    if ids.len() == 1 {
        file.write_all(format!("        \"{}\"\n", packet_id(&ids[0].id)).as_bytes()).unwrap();
    } else {
        let mut ids_with_version = ids.iter().filter(|id| id.packetver.is_some()).cloned().collect::<Vec<PacketId>>();
        let ids_without_version = ids.iter().filter(|id| id.packetver.is_none()).cloned().collect::<Vec<PacketId>>();
        if ids_without_version.len() > 1 {
            panic!("Cannot generate packet_id method when there is multiple id, and more than one(here {ids_without_version:?}) id has no version");
        }
        ids_with_version.sort_by(|a, b| (b.packetver.unwrap()).cmp(&a.packetver.unwrap()));
        for (index, id) in ids_with_version.iter().enumerate() {
            if index == 0 {
                file.write_all(format!("        if packetver >= {} {{\n", id.packetver.unwrap()).as_bytes()).unwrap();
            } else {
                file.write_all(format!("        }} else if packetver >= {} {{\n", id.packetver.unwrap()).as_bytes()).unwrap();
            }
            file.write_all(format!("            \"{}\"\n",  packet_id(&id.id)).as_bytes()).unwrap();
        }
        file.write_all("        } else {\n".to_string().as_bytes()).unwrap();
        file.write_all(format!("            \"{}\"\n", packet_id(&ids_without_version[0].id)).as_bytes()).unwrap();
        file.write_all("        }\n".to_string().as_bytes()).unwrap();
    }

    file.write_all("    }\n".to_string().as_bytes()).unwrap();
}

fn write_struct_new_method(file: &mut File, struct_definition: &StructDefinition, ids: &Option<Vec<PacketId>>) {
    file.write_all(format!("    pub fn new(packetver: u32) -> {} {{\n", struct_definition.name).as_bytes()).unwrap();
    if let Some(ids) = ids {
        let ids = ids.clone();
        if ids.len() == 1 {
            let id = packet_id(&ids[0].id).replace("0x", "");
            let (first_byte, second_byte) = id.split_at(2);
            file.write_all(format!("        let packet_id = i16::from_le_bytes([0x{first_byte}, 0x{second_byte}]);\n").as_bytes()).unwrap();
            file.write_all(format!("        let packet_id_raw = [0x{first_byte}, 0x{second_byte}];\n").as_bytes()).unwrap();
        } else {
            let mut ids_with_version = ids.iter().filter(|id| id.packetver.is_some()).cloned().collect::<Vec<PacketId>>();
            let ids_without_version = ids.iter().filter(|id| id.packetver.is_none()).cloned().collect::<Vec<PacketId>>();
            if ids_without_version.len() > 1 {
                panic!("Cannot generate new method when there is multiple id, and more than one(here {ids_without_version:?}) id has no version");
            }
            ids_with_version.sort_by(|a, b| (b.packetver.unwrap()).cmp(&a.packetver.unwrap()));
            for (index, id) in ids_with_version.iter().enumerate() {
                let packetid = packet_id(&id.id).replace("0x", "");
                let (first_byte, second_byte) = packetid.split_at(2);
                if index == 0 {
                    file.write_all(format!("        let (packet_id, packet_id_raw) = if packetver >= {} {{\n", id.packetver.unwrap()).as_bytes()).unwrap();
                } else {
                    file.write_all(format!("        }} else if packetver >= {} {{\n", id.packetver.unwrap()).as_bytes()).unwrap();
                }
                file.write_all(format!("            (i16::from_le_bytes([0x{first_byte}, 0x{second_byte}]), [0x{first_byte}, 0x{second_byte}])\n").as_bytes()).unwrap();
            }
            let packetid = packet_id(&ids_without_version[0].id).replace("0x", "");
            let (first_byte, second_byte) = packetid.split_at(2);
            file.write_all("        } else {\n".to_string().as_bytes()).unwrap();
            file.write_all(format!("            (i16::from_le_bytes([0x{first_byte}, 0x{second_byte}]), [0x{first_byte}, 0x{second_byte}])\n").as_bytes()).unwrap();
            file.write_all("        };\n".to_string().as_bytes()).unwrap();
        }
    }

    file.write_all(format!("        {} {{\n", struct_definition.name).as_bytes()).unwrap();
    file.write_all("        raw: vec![],\n".to_string().as_bytes()).unwrap();
    for field in &struct_definition.fields {
        if field.name == "packet_id" {
            file.write_all("        packet_id,\n".to_string().as_bytes()).unwrap();
            file.write_all("        packet_id_raw,\n".to_string().as_bytes()).unwrap();
        } else {
            file.write_all(field_default_value(field).as_bytes()).unwrap();
        }
    }
    file.write_all("        }\n".to_string().as_bytes()).unwrap();
    file.write_all("    }\n".to_string().as_bytes()).unwrap();
}

fn write_vec_field(file: &mut File, field: &StructField) {
    file.write_all(format!("        let vec_type_len = {}::base_len(packetver);\n", field.complex_type.as_ref().unwrap()).as_bytes()).unwrap();
    file.write_all(format!("        let iter_count = (&buffer.len() - {}) / vec_type_len;\n", field.position).as_bytes()).unwrap();
    file.write_all(format!("        let mut vec_field: Vec<{}> = Vec::new();\n", field.complex_type.as_ref().unwrap()).as_bytes()).unwrap();
    file.write_all("        let mut i = 1;\n".to_string().as_bytes()).unwrap();
    file.write_all("        while i <= iter_count {\n".to_string().as_bytes()).unwrap();
    file.write_all(format!("            let start_pos = {} + (vec_type_len * (i - 1));\n", field.position).as_bytes()).unwrap();
    file.write_all(format!("            let end_pos = {} + vec_type_len * i;\n", field.position).as_bytes()).unwrap();
    file.write_all(format!("            vec_field.push({}::from(&buffer[start_pos..end_pos], packetver));\n", field.complex_type.as_ref().unwrap()).as_bytes()).unwrap();
    file.write_all("            i += 1;\n".to_string().as_bytes()).unwrap();
    file.write_all("        }\n".to_string().as_bytes()).unwrap();
}

fn write_unknown_packet(file: &mut File) {
    file.write_all("#[derive(Debug)]\n".to_string().as_bytes()).unwrap();
    file.write_all("pub struct PacketUnknown {\n".to_string().as_bytes()).unwrap();
    file.write_all("    pub raw: Vec<u8>,\n".to_string().as_bytes()).unwrap();
    file.write_all("    pub packet_id: String,\n".to_string().as_bytes()).unwrap();
    file.write_all("}\n".to_string().as_bytes()).unwrap();
    file.write_all("impl Packet for PacketUnknown {\n".to_string().as_bytes()).unwrap();
    file.write_all("    fn id(&self, _packetver: u32) -> &str {\n".to_string().as_bytes()).unwrap();
    file.write_all("        self.packet_id.as_str()\n".to_string().as_bytes()).unwrap();
    file.write_all("    }\n".to_string().as_bytes()).unwrap();
    file.write_all("    fn name(&self) -> &str {\n".to_string().as_bytes()).unwrap();
    file.write_all("        \"Unknown\"\n".to_string().as_bytes()).unwrap();
    file.write_all("    }\n".to_string().as_bytes()).unwrap();
    file.write_all("    fn debug(&self) {\n".to_string().as_bytes()).unwrap();
    file.write_all("            println!(\"{:?}\", self)\n".to_string().as_bytes()).unwrap();
    file.write_all("    }\n".to_string().as_bytes()).unwrap();
    file.write_all("    fn display(&self) {\n".to_string().as_bytes()).unwrap();
    file.write_all("            self.debug()\n".to_string().as_bytes()).unwrap();
    file.write_all("    }\n".to_string().as_bytes()).unwrap();
    file.write_all("    fn pretty_debug(&self) {\n".to_string().as_bytes()).unwrap();
    file.write_all("            self.debug()\n".to_string().as_bytes()).unwrap();
    file.write_all("    }\n".to_string().as_bytes()).unwrap();
    file.write_all("    fn raw(&self) -> &Vec<u8> {\n".to_string().as_bytes()).unwrap();
    file.write_all("            &self.raw\n".to_string().as_bytes()).unwrap();
    file.write_all("    }\n".to_string().as_bytes()).unwrap();
    file.write_all("    fn raw_mut(&mut self) -> &mut Vec<u8> {\n".to_string().as_bytes()).unwrap();
    file.write_all("            &mut self.raw\n".to_string().as_bytes()).unwrap();
    file.write_all("    }\n".to_string().as_bytes()).unwrap();
    file.write_all("    fn as_any(&self) -> &dyn Any{\n".to_string().as_bytes()).unwrap();
    file.write_all("        self\n".to_string().as_bytes()).unwrap();
    file.write_all("    }\n".to_string().as_bytes()).unwrap();
    file.write_all("    fn as_any_mut(&mut self) -> &mut dyn Any{\n".to_string().as_bytes()).unwrap();
    file.write_all("        self\n".to_string().as_bytes()).unwrap();
    file.write_all("    }\n".to_string().as_bytes()).unwrap();
    file.write_all("    fn base_len(&self, _packetver: u32) -> usize {\n".to_string().as_bytes()).unwrap();
    file.write_all("        0\n".to_string().as_bytes()).unwrap();
    file.write_all("    }\n".to_string().as_bytes()).unwrap();
    file.write_all("    fn to_json(&self, _packetver: u32) -> String {\n".to_string().as_bytes()).unwrap();
    file.write_all("        String::new()\n".to_string().as_bytes()).unwrap();
    file.write_all("    }\n".to_string().as_bytes()).unwrap();
    file.write_all("    fn fill_raw(&mut self) {\n".to_string().as_bytes()).unwrap();
    file.write_all("        \n".to_string().as_bytes()).unwrap();
    file.write_all("    }\n".to_string().as_bytes()).unwrap();
    file.write_all("    fn fill_raw_with_packetver(&mut self, _packetver: Option<u32>) {\n".to_string().as_bytes()).unwrap();
    file.write_all("        \n".to_string().as_bytes()).unwrap();
    file.write_all("    }\n".to_string().as_bytes()).unwrap();
    file.write_all("}\n".to_string().as_bytes()).unwrap();
    file.write_all("impl PacketUnknown {\n".to_string().as_bytes()).unwrap();
    file.write_all("    pub fn from(buffer: &[u8]) -> PacketUnknown {\n".to_string().as_bytes()).unwrap();
    file.write_all("        if buffer.len() >= 2 {\n".to_string().as_bytes()).unwrap();
    file.write_all("          PacketUnknown { raw: buffer.to_vec(), packet_id: format!(\"0x{:02X?}{:02X?}\", buffer[0], buffer[1])}\n".to_string().as_bytes()).unwrap();
    file.write_all("        } else { \n".to_string().as_bytes()).unwrap();
    file.write_all("          PacketUnknown { raw: buffer.to_vec(), packet_id: \"0x??\".to_string()}\n".to_string().as_bytes()).unwrap();
    file.write_all("        }\n".to_string().as_bytes()).unwrap();
    file.write_all("    }\n".to_string().as_bytes()).unwrap();
    file.write_all("    pub fn from_json(_entries: Vec<json_flat_parser::FlatJsonValue<&str>>, _packetver: u32) -> Result<Self, String> {\n".to_string().as_bytes()).unwrap();
    file.write_all("          Ok(PacketUnknown { raw: vec![], packet_id: \"0x??\".to_string()})\n".to_string().as_bytes()).unwrap();
    file.write_all("    }\n".to_string().as_bytes()).unwrap();
    file.write_all("}\n".to_string().as_bytes()).unwrap();
}

fn write_struct_to_json(file: &mut File, struct_definition: &StructDefinition) {
    file.write_all("    fn to_json(&self, packetver: u32) -> String {\n".as_bytes()).unwrap();
    file.write_all("        let mut json = String::from(\"{\\n\");\n".as_bytes()).unwrap();
    for field in &struct_definition.fields {
        let mut json_value = String::new();
        if field.name.eq("packet_id") {
            json_value = format!("format!(\"\\\"{{}}\\\"\", {})","self.id(packetver)");
        } else {
            match field.data_type.name.as_str() {
                "Array" => {
                    if field.sub_type.is_some() {
                        let sub_type_name = &field.sub_type.unwrap().name;
                        // Special case for pos and dest so it is easier to read/edit json
                        if field.name.eq("pos_dir") || field.name.eq("dest") {
                            file.write_all(format!("        let x = ((self.{}[0] as u16) << 2) | (self.{}[1] >> 6) as u16;\n", field.name, field.name).as_bytes()).unwrap();
                            file.write_all(format!("        let y = (((self.{}[1] & 0x3f) as u16) << 4) | (self.{}[2] >> 4) as u16;\n", field.name, field.name).as_bytes()).unwrap();
                            file.write_all(format!("        let dir: u16 = (self.{}[2] & 0x0f) as u16;\n", field.name).as_bytes()).unwrap();
                            json_value = format!("format!(\"{{{{\\\"x\\\": {{}}, \\\"y\\\": {{}}, \\\"dir\\\": {{}}}}}}\", x, y, dir)");
                        } else if sub_type_name == "char" {
                            json_value = format!("format!(\"\\\"{{}}\\\"\", {})", format!("self.{}.iter().collect::<String>()", field.name));
                        } else {
                            json_value = format!("format!(\"[{{}}]\", {})", format!("self.{}.iter().map(|byte| byte.to_string()).collect::<Vec<String>>().join(\",\")", field.name));
                        }
                    }
                }
                "String" | "char" => {
                    json_value = format!("format!(\"\\\"{{}}\\\"\", {})", format!("self.{}", field.name));
                }
                "u8" | "i8" | "u16" | "i16" | "u32" | "i32" | "u64" | "i64" | "bool" => {
                    json_value = format!("self.{}.to_string()", field.name);
                }
                "Vec" | "Struct" => {}
                _ => {}
            }
        }

        if !json_value.is_empty() {
            file.write_all(format!("        json.push_str(\
            format!(\"\\\"{}\\\": {{}},\\n\",{}).as_str());\n", field.name, json_value).as_bytes()).unwrap();
        }
    }
    file.write_all("        json.pop();\n".as_bytes()).unwrap();
    file.write_all("        json.pop();\n".as_bytes()).unwrap();
    file.write_all("        json.push_str(\"\\n}\");\n".as_bytes()).unwrap();
    file.write_all("        json\n".as_bytes()).unwrap();
    file.write_all("    }\n".as_bytes()).unwrap();
}


fn write_struct_from_json(file: &mut File, struct_definition: &StructDefinition) {
    file.write_all("    #[allow(unused_mut)]\n".as_bytes()).unwrap();
    file.write_all("    pub fn from_json(entries: Vec<json_flat_parser::FlatJsonValue<&str>>, packetver: u32) -> Result<Self, String> {\n".as_bytes()).unwrap();

    file.write_all(format!("        let mut packet = {}::new(packetver);\n", struct_definition.name).as_bytes()).unwrap();

    for field in &struct_definition.fields {
        if field.name.eq("packet_id") {
            continue;
        }
        match field.data_type.name.as_str() {
            "Array" => {
                if let Some(sub_type) = field.sub_type {
                    if field.name.eq("pos_dir") || field.name.eq("dest") {
                        file.write_all(format!("                let x: u16 = entries.iter().find(|entry| entry.pointer.pointer.eq(\"/{}/x\")).unwrap().value.unwrap().parse().map_err(|_| \"Invalid value x for {}\".to_string())?;\n", field.name, field.name).as_bytes()).unwrap();
                        file.write_all(format!("                let y: u16 = entries.iter().find(|entry| entry.pointer.pointer.eq(\"/{}/y\")).unwrap().value.unwrap().parse().map_err(|_| \"Invalid value y for {}\".to_string())?;\n", field.name, field.name).as_bytes()).unwrap();
                        file.write_all(format!("                let dir: u16 = entries.iter().find(|entry| entry.pointer.pointer.eq(\"/{}/dir\")).unwrap().value.unwrap().parse().map_err(|_| \"Invalid value dir for {}\".to_string())?;\n", field.name, field.name).as_bytes()).unwrap();
                        file.write_all(format!("                let mut move_data: [{}; 3] = [0; 3];\n", sub_type.name).as_bytes()).unwrap();
                        file.write_all(format!("                move_data[0] = (x >> 2) as {};\n", sub_type.name).as_bytes()).unwrap();
                        file.write_all(format!("                move_data[1] = ((x << 6) | ((y >> 4) & 0x3f)) as {};\n", sub_type.name).as_bytes()).unwrap();
                        file.write_all(format!("                move_data[2] = ((y << 4) | (dir & 0xf)) as {};\n", sub_type.name).as_bytes()).unwrap();
                        file.write_all(format!("                packet.set_{}(move_data);\n", field.name).as_bytes()).unwrap();
                    }
                }
            }
            _ => {}
        }
        file.write_all(format!("        if let Some(entry) = entries.iter().find(|entry| entry.pointer.pointer.eq(\"/{}\")) {{\n", field.name).as_bytes()).unwrap();
        file.write_all("            if let Some(value) = entry.value {\n".as_bytes()).unwrap();
        match field.data_type.name.as_str() {
            "Array" => {
                if let Some(sub_type) = field.sub_type {
                    let sub_type_name = &sub_type.name;
                    if field.name.eq("pos_dir") || field.name.eq("dest") {

                    } else if sub_type_name == "char" {
                        file.write_all(format!("                let mut char_value: [char; {}] = [0 as char; {}];\n", field.length, field.length).as_bytes()).unwrap();
                        file.write_all("                for (i, c) in value.chars().enumerate() {\n".as_bytes()).unwrap();
                        file.write_all("                    if i >= char_value.len() {\n".as_bytes()).unwrap();
                        file.write_all("                        break;\n".as_bytes()).unwrap();
                        file.write_all("                    }\n".as_bytes()).unwrap();
                        file.write_all("                    char_value[i] = c;\n".as_bytes()).unwrap();
                        file.write_all("                }\n".as_bytes()).unwrap();
                        file.write_all(format!("                packet.set_{}(char_value);\n", field.name).as_bytes()).unwrap();
                    } else {}
                }
            }
            "String" => {
                file.write_all(format!("                packet.set_{}(value.to_string());\n", field.name).as_bytes()).unwrap();
            }
            "u8" | "i8" | "u16" | "i16" | "u32" | "i32" | "u64" | "i64" | "bool" => {
                file.write_all(format!("                packet.set_{}(value.parse().map_err(|_| format!(\"Invalid value {{}} for {}\", value))?);\n", field.name, field.name).as_bytes()).unwrap();
            }
            "Vec" | "Struct" => {}
            _ => {}
        }
        file.write_all("            }\n".as_bytes()).unwrap();
        file.write_all("        }\n".as_bytes()).unwrap();
    }
    file.write_all("        Ok(packet)\n".as_bytes()).unwrap();
    file.write_all("    }\n".as_bytes()).unwrap();
}

fn struct_impl_field_value(field: &StructField) -> String {
    match field.data_type.name.as_str() {
        "char" => {
            String::from("buffer[offset] as char")
        }
        "u8" => {
            String::from("u8::from_le_bytes([buffer[offset]])")
        }
        "i8" => {
            String::from("i8::from_le_bytes([buffer[offset]])")
        }
        "u16" => {
            String::from("u16::from_le_bytes([buffer[offset], buffer[offset + 1]])")
        }
        "i16" => {
            String::from("i16::from_le_bytes([buffer[offset], buffer[offset + 1]])")
        }
        "u32" => {
            String::from("u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]])")
        }
        "i32" => {
            String::from("i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]])")
        }
        "u64" => {
            String::from("u64::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3], buffer[offset + 4], buffer[offset + 5], buffer[offset + 6], buffer[offset + 7]])")
        }
        "i64" => {
            String::from("i64::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3], buffer[offset + 4], buffer[offset + 5], buffer[offset + 6], buffer[offset + 7]])")
        }
        "bool" => {
            String::from("buffer[offset] == 1")
        }
        "String" => {
            "String::from_utf8_lossy(&buffer[offset..(buffer.len() - 1)]).to_string()".to_string()
        }
        "Array" => {
            let mut array_block = " {\n".to_string();
            let length = &field.length;
            if field.sub_type.is_some() &&  field.length > -1 {
                let sub_type_name = &field.sub_type.unwrap().name;
                if sub_type_name == "char" {
                    array_block = format!("{array_block}                let mut dst: [{sub_type_name}; {length}] = [0 as {sub_type_name}; {length}];\n");
                } else {
                    array_block = format!("{array_block}                let mut dst: [{sub_type_name}; {length}] = [0_{sub_type_name}; {length}];\n");
                }

                array_block = format!("{}                for (index, byte) in buffer[offset..offset + {}].iter().enumerate() {{\n", array_block, field.length);
                array_block = format!("{array_block}                    dst[index] = *byte as {sub_type_name};\n");
                array_block = format!("{array_block}                }}\n");
            } else if field.length > -1 {
                array_block = format!("{array_block}                let mut dst: [u8; {length}] = [0; {length}];\n");
                array_block = format!("{}                dst.clone_from_slice(&buffer[offset..offset + {}]);\n", array_block, field.length);
            } else if field.sub_type.is_some() {
                let sub_type_name = &field.sub_type.unwrap().name;
                array_block = format!("{array_block}                let mut dst: Vec<{sub_type_name}> = vec![];\n");
                let (read_array_entry, len) = match sub_type_name.as_str() {
                    "u8" => {
                        (String::from("u8::from_le_bytes([buffer[offset]])"), 1)
                    }
                    "i8" => {
                        (String::from("i8::from_le_bytes([buffer[offset]])"), 1)
                    }
                    "u16" => {
                        (String::from("u16::from_le_bytes([buffer[offset], buffer[offset + 1]])"), 2)
                    }
                    "i16" => {
                        (String::from("i16::from_le_bytes([buffer[offset], buffer[offset + 1]])"), 2)
                    }
                    "u32" => {
                        (String::from("u32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]])"), 4)
                    }
                    "i32" => {
                        (String::from("i32::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3]])"), 4)
                    }
                    "u64" => {
                        (String::from("u64::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3], buffer[offset + 4], buffer[offset + 5], buffer[offset + 6], buffer[offset + 7]])"), 8)
                    }
                    "i64" => {
                        (String::from("i64::from_le_bytes([buffer[offset], buffer[offset + 1], buffer[offset + 2], buffer[offset + 3], buffer[offset + 4], buffer[offset + 5], buffer[offset + 6], buffer[offset + 7]])"), 8)
                    }
                    _ => { panic!("Dont know of to read Vec<{}>", sub_type_name.as_str())}
                };

                array_block = format!("{array_block}                let offset_orig = offset;\n");
                array_block = format!("{array_block}                while (offset + {len} <= buffer.len()) {{\n");
                array_block = format!("{array_block}                    dst.push({read_array_entry});\n");
                array_block = format!("{array_block}                    offset += {len};\n");
                array_block = format!("{array_block}                }}\n");
                array_block = format!("{array_block}                offset = offset_orig;\n");
            } else {
                array_block = format!("{array_block}                let dst: Vec<u8> = buffer[offset..buffer.len()].to_vec();\n");
            }
            array_block = format!("{array_block}                dst\n            }}");
            array_block
        }
        _ => {
            format!("\"found unknown type {} for field {}. this won't compile!\"", field.data_type.name, field.name)
        }
    }
}

fn struct_impl_default_field_value(field: &StructField) -> String {
    match field.data_type.name.as_str() {
        "char" => {
            String::from("0 as char")
        }
        "u8" => {
            String::from("0 as u8")
        }
        "i8" => {
            String::from("0 as i8")
        }
        "u16" => {
            String::from("0 as u16")
        }
        "i16" => {
            String::from("0 as i16")
        }
        "u32" => {
            String::from("0 as u32")
        }
        "i32" => {
            String::from("0 as i32")
        }
        "u64" => {
            String::from("0 as u64")
        }
        "i64" => {
            String::from("0 as i64")
        }
        "bool" => {
            String::from("false")
        }
        "String" => {
            String::from("String::new()")
        }
        "Array" => {
            if field.sub_type.is_some() {
                let sub_type_name = &field.sub_type.unwrap().name;
                let length = &field.length;
                if sub_type_name == "char" {
                    format!("[0 as char; {length}]")
                } else {
                    format!("[{sub_type_name}; {length}]")
                }
            } else if field.length > -1 {
                format!("[0 as u8; {}]", field.length)
            } else {
                String::from("vec![]")
            }
        }
        _ => {
            format!("\"found unknown type {} for field {}. this won't compile!\"", field.data_type.name, field.name)
        }
    }
}

fn field_serialization(field: &StructField) -> String {
    let mut res = String::new();
    match field.data_type.name.as_str() {
        "char" => {
            res = "        wtr = vec![];\n".to_string();
            res = format!("{}        wtr.write_u8(self.{}).unwrap();\n", res, field.name);
            res = format!("{}        self.{}_raw = wtr.try_into().unwrap();", res, field.name);
            res
        }
        "bool" => {
            res = "        wtr = vec![];\n".to_string();
            res = format!("{}        wtr.write_u8(self.{} as u8).unwrap();\n", res, field.name);
            res = format!("{}        self.{}_raw = wtr.try_into().unwrap();", res, field.name);
            res
        }
        "u8" | "i8" => {
            res = "        wtr = vec![];\n".to_string();
            res = format!("{}        wtr.write_{}(self.{}).unwrap();\n", res, field.data_type.name, field.name);
            res = format!("{}        self.{}_raw = wtr.try_into().unwrap();", res, field.name);
            res
        }
        "u16" | "i16" | "u32" | "i32" | "u64" | "i64" => {
            res = "        wtr = vec![];\n".to_string();
            res = format!("{}        wtr.write_{}::<LittleEndian>(self.{}).unwrap();\n", res, field.data_type.name, field.name);
            res = format!("{}        self.{}_raw = wtr.try_into().unwrap();", res, field.name);
            res
        }
        "String" => {
            format!("        self.{}_raw = self.{}.as_bytes().to_vec();", field.name, field.name)
        }
        "Array" => {
            if field.sub_type.is_some() {
                res = "        wtr = vec![];\n".to_string();
                let sub_type = field.sub_type.unwrap();
                if sub_type.name == "u8" || sub_type.name == "i8" {
                    res = format!("{}        for item in self.{} {{\n", res, field.name);
                    res = format!("{}            wtr.write_{}(item).unwrap();\n", res, sub_type.name);
                    res = format!("{res}        }}\n");
                    res = format!("{}        self.{}_raw = wtr.try_into().unwrap();", res, field.name);
                } else if sub_type.name == "char" {
                    res = format!("{}        for item in self.{} {{\n", res, field.name);
                    res = format!("{res}            wtr.write_u8(item as u8 ).unwrap();\n");
                    res = format!("{res}        }}\n");
                    res = format!("{}        self.{}_raw = wtr.try_into().unwrap();", res, field.name);
                } else if field.length > -1 {
                    res = format!("{}        for item in self.{} {{\n", res, field.name);
                    res = format!("{}            wtr.write_{}::<LittleEndian>(item).unwrap();\n", res, sub_type.name);
                    res = format!("{res}        }}\n");
                } else {
                    res = format!("{}        self.{}_raw = self.{}.iter().flat_map(|&x| x.to_le_bytes()).collect::<Vec<u8>>();\n", res, field.name, field.name);
                }
                res
            } else {
                res
            }
        }
        "Vec" => {
            if field.complex_type.is_some() {
                res = format!("        self.{}_raw = {{\n", field.name);
                res = format!("{}            self.{}.iter_mut().for_each(|item| item.fill_raw_with_packetver(packetver));\n", res, field.name);
                res = format!("{}            self.{}.iter().map(|item| item.raw.clone()).collect()\n", res, field.name);
                res = format!("{res}      }};\n");
                res
            } else {
                format!("\"found unknown type {} for field {}. this won't compile!\"", field.data_type.name, field.name)
            }
        }
        "Struct" => {
            if field.complex_type.is_some() {
                res = format!("        self.{}.fill_raw_with_packetver(packetver);\n", field.name);
                if field.length > -1 {
                    res = format!("{}        self.{}_raw = self.{}.clone().raw.try_into().unwrap();\n", res, field.name, field.name);
                } else {
                    res = format!("{}        self.{}_raw = self.{}.clone().raw;\n", res, field.name, field.name);
                }
                res
            } else {
                format!("\"found unknown type {} for field {}. this won't compile!\"", field.data_type.name, field.name)
            }
        }
        _ => {
            format!("\"found unknown type {} for field {}. this won't compile!\"", field.data_type.name, field.name)
        }
    }
}

fn field_length(field: &StructField) -> String {
    if field.length > -1 { (field.length).to_string() } else { "buffer.len()".to_string() }
}

fn packet_id(packet_id: &str) -> String {
    let id = format!("{:0>4}", packet_id.replace("0x", ""));
    let (first_byte, second_byte) = id.split_at(2);
    format!("0x{second_byte}{first_byte}") // packet id in db are in Little Endian
}

fn display_type(field: &StructField) -> String {
    if field.data_type.name == "Array" && field.sub_type.is_some() {
        let sub_type = field.sub_type.unwrap();
        return format!("({}[] as {}[])", sub_type.cname, sub_type.name);
    }

    format!("({} as {})", field.data_type.cname, field.data_type.name)
}

fn field_type(field: &StructField) -> String {
    if field.data_type.name == "Vec" {
        format!("Vec<{}>", field.complex_type.as_ref().unwrap())
    } else if field.data_type.name == "Struct" {
        field.complex_type.as_ref().unwrap().to_string()
    } else if field.data_type.name == "Array" {
        if field.sub_type.is_some() && field.length > -1 {
            format!("[{}; {}]", &field.sub_type.unwrap().name, field.length)
        } else if field.sub_type.is_some(){
            format!("Vec<{}>", &field.sub_type.unwrap().name)
        } else {
            "Vec<u8>".to_string()
        }
    } else {
        field.data_type.name.to_string()
    }
}

fn field_type_raw(field: &StructField) -> String {
    if field.data_type.name == "Vec" {
        "Vec<Vec<u8>>".to_string()
    } else if field.length > -1 && field.data_type.name == "Array" {
        format!("[u8; {}]", field.length * field.sub_type.unwrap().length.unwrap())
    } else if field.length > -1 {
        format!("[u8; {}]", field.length)
    } else {
        "Vec<u8>".to_string()
    }
}

fn field_default_value(field: &StructField) -> String {
    let mut res = String::new();
    match field.data_type.name.as_str() {
        "char" => {
            res = format!("{}        {}: '',\n", res, field.name);
            res = format!("{}        {}_raw: 0,\n", res, field.name);
            res
        }
        "u8" | "i8" | "u16" | "i16" | "u32" | "i32" | "u64" | "i64" => {
            res = format!("{}        {}: 0,\n", res, field.name);
            res = format!("{}        {}_raw: [0; {}],\n", res, field.name, field.length);
            res
        }
        "bool" => {
            res = format!("{}        {}: false,\n", res, field.name);
            res = format!("{}        {}_raw: [0; 1],\n", res, field.name);
            res
        }
        "String" => {
            res = format!("{}        {}: String::new(),\n", res, field.name);
            res = format!("{}        {}_raw: vec![],\n", res, field.name);
            res
        }
        "Array" => {
            if field.length > -1 {
                let mut value = "0";
                if field.sub_type.unwrap().name == "char" {
                    value = "0 as char";
                }
                res = format!("{}        {}: [{}; {}],\n", res, field.name, value, field.length);
                res = format!("{}        {}_raw: [0; {}],\n", res, field.name, field.length * field.sub_type.unwrap().length.unwrap());
                res
            } else {
                res = format!("{}        {}: vec![],\n", res, field.name);
                res = format!("{}        {}_raw: vec![],\n", res, field.name);
                res
            }
        }
        "Vec" => {
            res = format!("{}        {}: vec![],\n", res, field.name);
            res = format!("{}        {}_raw: vec![],\n", res, field.name);
            res
        }
        "Struct" => {
            res = format!("{}        {}: {}::new(packetver),\n", res, field.name, field.complex_type.as_ref().unwrap());
            if field.length > -1 {
                res = format!("{}        {}_raw: [0; {}],\n", res, field.name, field.length);
            } else {
                res = format!("{}        {}_raw: vec![],\n", res, field.name);
            }
            res
        }
        _ => {
            panic!("\"found unknown type {} for field {}. this won't compile!\"", field.data_type.name, field.name)
        }
    }
}

fn packetver_if(packetver_variable: &str, field: &StructField) -> String {
    format!("if {} {} {{\n", packetver_variable,
            match field.condition.as_ref().unwrap() {
                Condition::GTE(ver) => format!(">= {ver}"),
                Condition::GT(ver) => format!("> {ver}"),
                Condition::LTE(ver) => format!("<= {ver}"),
                Condition::LT(ver) => format!("< {ver}"),
            })
}